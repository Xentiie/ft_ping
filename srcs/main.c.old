/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: reclaire <reclaire@student.42mulhouse.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/07 17:17:24 by reclaire          #+#    #+#             */
/*   Updated: 2024/08/28 23:54:45 by reclaire         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_ping.h"
#include "libft/std.h"
#include "libft/limits.h"
#include "libft/strings.h"
#include "libft/time.h"
#include "libft/io.h"
#include "libft/socket.h"
#include "libft/getopt.h"

#ifndef __USE_MISC
#define __USE_MISC 1
#endif
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include <sys/ioctl.h>
#include <sys/socket.h>

#include <arpa/inet.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>

static void print_help();
static U16 checksum(U16 *ptr, U64 nbytes);
static void init_ip_header(t_ip_header *header);
static void init_icmp_header(t_ip_header *ip_header, t_icmp_header *header, U64 payload_size, U32 src_addr, U32 dst_addr);

/*
Opens raw socket ( socket(AF_INET, SOCK_RAW, IPPROTO_ICMP) )
+ setsockopt IPPROTO_IP IP_HDRINCL
+ setsockopt SOL_SOCKET SO_BROADCAST
*/
static file init_socket();
static S64 send_data(file sock, U8 *data, S64 data_size, struct sockaddr_in *addr);

// Need to update icmp checksum after data has been set
struct s_icmp_packet create_icmp_echo(U32 src_addr, U32 dst_addr, U64 payload_size)
{
	t_ip_header *ip;
	t_icmp_header *icmp;
	const U64 icmp_header_len = 8;

	struct s_icmp_packet out = {0};

	out.packet_size = sizeof(t_ip_header) + /* sizeof(t_icmp_header) */ icmp_header_len + payload_size;
	if ((out.packet = malloc(sizeof(U8) * out.packet_size)) == NULL)
		return (struct s_icmp_packet){0};
	ft_memset(out.packet, 0, out.packet_size);

	ip = (t_ip_header *)out.packet;
	icmp = (t_icmp_header *)(out.packet + sizeof(t_ip_header));
	out.payload = out.packet + sizeof(t_ip_header) + icmp_header_len;

	init_icmp_header(ip, icmp, payload_size, src_addr, dst_addr);
	ip->len = htons(sizeof(t_ip_header) + 8 /* ICMP_MSG_ECHO */ + payload_size);

	icmp->type = ICMP_MSG_ECHO;
	icmp->code = 0;
	icmp->req.echo.id = rand();
	icmp->req.echo.seq = rand();
	icmp->checksum = 0;

	return out;
}
void update_checksum_icmp(U8 *packet, U64 payload_size)
{
	t_icmp_header *icmp = (t_icmp_header *)(packet + sizeof(t_ip_header));
	icmp->checksum = 0;
	icmp->checksum = checksum((U16 *)icmp, sizeof(struct icmphdr) + payload_size);
}

bool get_host_addr(struct sockaddr *addr)
{
	file sock;
	struct ifreq ifr = {0};

	if ((sock = ft_socket(AF_INET, SOCK_DGRAM, 0)) == (file)-1)
	{
		ft_dprintf(ft_stderr, "error: socket 2\n");
		return FALSE;
	}
	ifr.ifr_addr.sa_family = AF_INET;
	ft_strlcpy(ifr.ifr_name, "wlo1", IFNAMSIZ - 1);

	if (ioctl(sock, SIOCGIFADDR, &ifr) == -1)
	{
		ft_dprintf(ft_stderr, "error: ioctl: %s\n", strerror(errno));
		close(sock);
		return FALSE;
	}

	close(sock);
	*addr = ifr.ifr_addr;
	return TRUE;
}

int main(S32 argc, const_string *argv)
{
	bool verbose = FALSE;
	struct sockaddr_in dst_addr = {0};
	struct sockaddr_in src_addr = {0};
	U64 payload_size = 56;
	file sock;

	{ // Args
		S32 v;
		ft_optchr = '!';
		while ((v = ft_getopt(argc, argv, "s:v?")) != -1)
		{
			switch (v)
			{
			case 's':
				if (!ft_str_isdigit((string)ft_optarg))
				{
					ft_dprintf(ft_errno, "%s: invalid argument: '%s'\n", ft_argv[0], ft_optarg);
					return 1;
				}
				payload_size = ft_atoi(ft_optarg);
				break;
				
			case 'v':
				verbose = TRUE;
				break;
			case '!':
				ft_printf("\n");
				/* fallthrough */
			case '?':
				print_help();
				return 2;
			}
		}

		if (ft_optind >= argc)
		{
			ft_dprintf(ft_stderr, "%s: usage error: Destination address required\n", ft_argv[0]);
			return 1;
		}

		dst_addr.sin_family = AF_INET;
		if (inet_aton(argv[ft_optind], &dst_addr.sin_addr) == -1)
		{
			ft_dprintf(ft_stderr, "%s: %s: Name or service not known\n", ft_argv[0]);
			return 2;
		}
	}

	if (get_host_addr((struct sockaddr *)&src_addr) == FALSE)
		return 1;

	if ((sock = init_socket()) == -1)
		return 1;


	// Loop

	struct s_icmp_packet echo = create_icmp_echo(src_addr.sin_addr.s_addr, dst_addr.sin_addr.s_addr, payload_size);
	if (echo.packet == NULL)
	{
		ft_dprintf(ft_stderr, "%s: out of memory\n");
		return 1;
	}
	for (U64 i = 0; i < payload_size; i++)
		echo.payload[i] = i;
	update_checksum_icmp(echo.packet, payload_size);

	ft_printf("PING %s (%s) %ld(%ld) bytes of data.", argv[ft_optind], argv[ft_optind], payload_size, echo.packet_size);

	U64 sent = send_data(sock, echo.packet, echo.packet_size, &dst_addr);

	t_clock clk;
	ft_clk_init(&clk);
	ft_clk_start(&clk);

	U8 buffer[256] = {0};
	{ // Receive response
		U32 addr_len = sizeof(struct sockaddr_in);
		S64 received = 0, tmp = 0;
		while (received == 0 && (tmp = recvfrom(sock, buffer + received, sizeof(buffer) - received, 0, (struct sockaddr *)&dst_addr, &addr_len)) > 0)
			received += tmp;
		if (tmp < 0)
		{
			ft_dprintf(ft_stderr, "error: recvfrom\n"); // TODO: check error codes + error message
			return 1;
		}
	}

	ft_clk_stop(&clk);
	S64 secs;
	S64 nsecs;
	ft_clk_diff(&clk.t1, &clk.t2, &secs, &nsecs);

	U8 *buf = buffer;
	buf += sizeof(t_ip_header);
	switch (*buf)
	{
	case ICMP_ECHOREPLY:
		
		break;
	}

	ft_printf("%ld bytes from %s: icmp_seq=%u ttl=%u time=%.1fms\n", 0, "", 0, 0, (F32)(nsecs / 1e6) + (secs * 1000));

	free(echo.packet);
	close(sock);

	return 0;
}

static file init_socket()
{
	file sock;

	if ((sock = ft_socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) == -1)
	{
		ft_dprintf(ft_stderr, "error: socket: %s\n", strerror(errno)); // TODO: check error codes + error message
		return -1;
	}

	S32 on = 1;
	if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (const char *)&on, sizeof(on)) == -1)
	{
		close(sock);								  // TODO: ft_close
		ft_dprintf(ft_stderr, "error: setsockopt\n"); // TODO: check error codes + error message
		return -1;
	}

	// allow socket to send datagrams to broadcast addresses
	if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (const char *)&on, sizeof(on)) == -1)
	{
		close(sock);
		ft_dprintf(ft_stderr, "error: setsockopt\n"); // TODO: check error codes + error message
		return -1;
	}

	return sock;
}

static void init_ip_header(t_ip_header *header)
{
	ft_memset(header, 0, sizeof(t_ip_header));
}

// Need to update len
static void init_icmp_header(t_ip_header *ip_header, t_icmp_header *header, U64 payload_size, U32 src_addr, U32 dst_addr)
{
	init_ip_header(ip_header);
	ip_header->ver = 4;
	ip_header->ihl = sizeof(t_ip_header) / 4;
	ip_header->tos = 0;
	//ip_header->len = htons(sizeof(t_ip_header) + 8 + payload_size);
	ip_header->id = rand();
	ip_header->ttl = U8_MAX;
	ip_header->protocol = IPPROTO_ICMP;
	ip_header->src_addr = src_addr;
	ip_header->dst_addr = dst_addr;
	ip_header->check = checksum((U16 *)ip_header, sizeof(t_ip_header));

	ft_memset(header, 0, sizeof(t_icmp_header));
}

static S64 send_data(file sock, U8 *data, S64 data_size, struct sockaddr_in *addr)
{
	S64 sent = 0, tmp = 0;

	while (data_size - sent > 0 && (tmp = sendto(sock, data + sent, data_size - sent, 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in))) > 0)
		sent += tmp;
	if (tmp < 0)
	{
		ft_dprintf(ft_stderr, "error: sendto: %s\n", strerror(errno)); // TODO: check error codes + error message
		return -1;
	}
	return sent;
}

static U16 checksum(U16 *ptr, U64 nbytes)
{
	U64 sum;
	U16 oddbyte;
	U16 answer;

	sum = 0;
	while (nbytes > 1)
	{
		sum += *ptr++;
		nbytes -= 2;
	}

	if (nbytes == 1)
	{
		oddbyte = 0;
		*((U8 *)&oddbyte) = *(U8 *)ptr;
		sum += oddbyte;
	}

	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);
	answer = ~sum;

	return answer;
}

static void print_help()
{
	ft_printf(
		"Usage\n\
  ping [options] <destination>\n\
\n\
Options:\n\
  <destination>      dns name or ip address\n\
  -a                 use audible ping\n\
  -A                 use adaptive ping\n\
  -B                 sticky source address\n\
  -c <count>         stop after <count> replies\n\
  -D                 print timestamps\n\
  -d                 use SO_DEBUG socket option\n\
  -f                 flood ping\n\
  -h                 print help and exit\n\
  -I <interface>     either interface name or address\n\
  -i <interval>      seconds between sending each packet\n\
  -L                 suppress loopback of multicast packets\n\
  -l <preload>       send <preload> number of packages while waiting replies\n\
  -m <mark>          tag the packets going out\n\
  -M <pmtud opt>     define mtu discovery, can be one of <do|dont|want>\n\
  -n                 no dns name resolution\n\
  -O                 report outstanding replies\n\
  -p <pattern>       contents of padding byte\n\
  -q                 quiet output\n\
  -Q <tclass>        use quality of service <tclass> bits\n\
  -s <size>          use <size> as number of data bytes to be sent\n\
  -S <size>          use <size> as SO_SNDBUF socket option value\n\
  -t <ttl>           define time to live\n\
  -U                 print user-to-user latency\n\
  -v                 verbose output\n\
  -V                 print version and exit\n\
  -w <deadline>      reply wait <deadline> in seconds\n\
  -W <timeout>       time to wait for response\n\
\n\
IPv4 options:\n\
  -4                 use IPv4\n\
  -b                 allow pinging broadcast\n\
  -R                 record route\n\
  -T <timestamp>     define timestamp, can be one of <tsonly|tsandaddr|tsprespec>\n\
\n\
IPv6 options:\n\
  -6                 use IPv6\n\
  -F <flowlabel>     define flow label, default is random\n\
  -N <nodeinfo opt>  use icmp6 node info query, try <help> as argument\n");
}